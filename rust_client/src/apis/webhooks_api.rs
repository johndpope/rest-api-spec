/*
 * Figma API
 *
 * This is the OpenAPI specification for the [Figma REST API](https://www.figma.com/developers/api).  Note: we are releasing the OpenAPI specification as a beta given the large surface area and complexity of the REST API. If you notice any inaccuracies with the specification, please [file an issue](https://github.com/figma/rest-api-spec/issues).
 *
 * The version of the OpenAPI document: 0.35.0
 * Contact: support@figma.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`delete_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteWebhookError {
    Status400(models::GetTeamProjects400Response),
    Status403(models::GetFile403Response),
    Status404(models::GetTeamComponents404Response),
    Status429(models::GetFile429Response),
    Status500(models::DeleteWebhook500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_team_webhooks`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTeamWebhooksError {
    Status403(models::GetFile403Response),
    Status404(models::GetFile404Response),
    Status429(models::GetFile429Response),
    Status500(models::GetFile500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetWebhookError {
    Status400(models::GetTeamProjects400Response),
    Status403(models::GetFile403Response),
    Status404(models::GetTeamComponents404Response),
    Status429(models::GetFile429Response),
    Status500(models::GetFile500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_webhook_requests`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetWebhookRequestsError {
    Status400(models::GetTeamProjects400Response),
    Status403(models::GetFile403Response),
    Status404(models::GetTeamComponents404Response),
    Status429(models::GetFile429Response),
    Status500(models::DeleteWebhook500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_webhooks`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetWebhooksError {
    Status400(models::GetTeamProjects400Response),
    Status403(models::GetFile403Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostWebhookError {
    Status400(models::GetTeamProjects400Response),
    Status403(models::GetFile403Response),
    Status429(models::GetFile429Response),
    Status500(models::GetFile500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`put_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PutWebhookError {
    Status400(models::GetTeamProjects400Response),
    Status403(models::GetFile403Response),
    Status404(models::GetTeamComponents404Response),
    Status429(models::GetFile429Response),
    Status500(models::GetFile500Response),
    UnknownValue(serde_json::Value),
}


/// Deletes the specified webhook. This operation cannot be reversed.
pub async fn delete_webhook(configuration: &configuration::Configuration, webhook_id: &str) -> Result<models::WebhookV2, Error<DeleteWebhookError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_webhook_id = webhook_id;

    let uri_str = format!("{}/v2/webhooks/{webhook_id}", configuration.base_path, webhook_id=crate::apis::urlencode(p_webhook_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Figma-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WebhookV2`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WebhookV2`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteWebhookError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns all webhooks registered under the specified team.
pub async fn get_team_webhooks(configuration: &configuration::Configuration, team_id: &str) -> Result<models::GetTeamWebhooks200Response, Error<GetTeamWebhooksError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_team_id = team_id;

    let uri_str = format!("{}/v2/teams/{team_id}/webhooks", configuration.base_path, team_id=crate::apis::urlencode(p_team_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Figma-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTeamWebhooks200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTeamWebhooks200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTeamWebhooksError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a webhook by ID.
pub async fn get_webhook(configuration: &configuration::Configuration, webhook_id: &str) -> Result<models::WebhookV2, Error<GetWebhookError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_webhook_id = webhook_id;

    let uri_str = format!("{}/v2/webhooks/{webhook_id}", configuration.base_path, webhook_id=crate::apis::urlencode(p_webhook_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Figma-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WebhookV2`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WebhookV2`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetWebhookError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns all webhook requests sent within the last week. Useful for debugging.
pub async fn get_webhook_requests(configuration: &configuration::Configuration, webhook_id: &str) -> Result<models::GetWebhookRequests200Response, Error<GetWebhookRequestsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_webhook_id = webhook_id;

    let uri_str = format!("{}/v2/webhooks/{webhook_id}/requests", configuration.base_path, webhook_id=crate::apis::urlencode(p_webhook_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Figma-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetWebhookRequests200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetWebhookRequests200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetWebhookRequestsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a list of webhooks corresponding to the context or plan provided, if they exist. For plan, the webhooks for all contexts that you have access to will be returned, and theresponse is paginated
pub async fn get_webhooks(configuration: &configuration::Configuration, context: Option<&str>, context_id: Option<&str>, plan_api_id: Option<&str>, cursor: Option<&str>) -> Result<models::GetWebhooks200Response, Error<GetWebhooksError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_context = context;
    let p_context_id = context_id;
    let p_plan_api_id = plan_api_id;
    let p_cursor = cursor;

    let uri_str = format!("{}/v2/webhooks", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_context {
        req_builder = req_builder.query(&[("context", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_context_id {
        req_builder = req_builder.query(&[("context_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_plan_api_id {
        req_builder = req_builder.query(&[("plan_api_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_cursor {
        req_builder = req_builder.query(&[("cursor", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Figma-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetWebhooks200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetWebhooks200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetWebhooksError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a new webhook which will call the specified endpoint when the event triggers. By default, this webhook will automatically send a PING event to the endpoint when it is created. If this behavior is not desired, you can create the webhook and set the status to PAUSED and reactivate it later.
pub async fn post_webhook(configuration: &configuration::Configuration, post_webhook_request: models::PostWebhookRequest) -> Result<models::WebhookV2, Error<PostWebhookError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_post_webhook_request = post_webhook_request;

    let uri_str = format!("{}/v2/webhooks", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Figma-Token", value);
    };
    req_builder = req_builder.json(&p_post_webhook_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WebhookV2`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WebhookV2`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostWebhookError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update a webhook by ID.
pub async fn put_webhook(configuration: &configuration::Configuration, webhook_id: &str, put_webhook_request: models::PutWebhookRequest) -> Result<models::WebhookV2, Error<PutWebhookError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_webhook_id = webhook_id;
    let p_put_webhook_request = put_webhook_request;

    let uri_str = format!("{}/v2/webhooks/{webhook_id}", configuration.base_path, webhook_id=crate::apis::urlencode(p_webhook_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Figma-Token", value);
    };
    req_builder = req_builder.json(&p_put_webhook_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WebhookV2`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WebhookV2`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PutWebhookError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

