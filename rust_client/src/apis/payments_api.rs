/*
 * Figma API
 *
 * This is the OpenAPI specification for the [Figma REST API](https://www.figma.com/developers/api).  Note: we are releasing the OpenAPI specification as a beta given the large surface area and complexity of the REST API. If you notice any inaccuracies with the specification, please [file an issue](https://github.com/figma/rest-api-spec/issues).
 *
 * The version of the OpenAPI document: 0.35.0
 * Contact: support@figma.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`get_payments`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPaymentsError {
    Status401(models::GetActivityLogs401Response),
    Status429(models::GetActivityLogs429Response),
    Status500(models::DeleteWebhook500Response),
    UnknownValue(serde_json::Value),
}


/// There are two methods to query for a user's payment information on a plugin, widget, or Community file. The first method, using plugin payment tokens, is typically used when making queries from a plugin's or widget's code. The second method, providing a user ID and resource ID, is typically used when making queries from anywhere else.  Note that you can only query for resources that you own. In most cases, this means that you can only query resources that you originally created.
pub async fn get_payments(configuration: &configuration::Configuration, plugin_payment_token: Option<&str>, user_id: Option<&str>, community_file_id: Option<&str>, plugin_id: Option<&str>, widget_id: Option<&str>) -> Result<models::GetPayments200Response, Error<GetPaymentsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_plugin_payment_token = plugin_payment_token;
    let p_user_id = user_id;
    let p_community_file_id = community_file_id;
    let p_plugin_id = plugin_id;
    let p_widget_id = widget_id;

    let uri_str = format!("{}/v1/payments", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_plugin_payment_token {
        req_builder = req_builder.query(&[("plugin_payment_token", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_user_id {
        req_builder = req_builder.query(&[("user_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_community_file_id {
        req_builder = req_builder.query(&[("community_file_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_plugin_id {
        req_builder = req_builder.query(&[("plugin_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_widget_id {
        req_builder = req_builder.query(&[("widget_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Figma-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetPayments200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetPayments200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPaymentsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

